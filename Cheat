local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/JusticeTakeOver/Lib/main/UIL'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local player = game:GetService("Players").LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local events = ReplicatedStorage:WaitForChild("Events")
local PlayerF = game:GetService("Players")
local playerman = PlayerF.LocalPlayer
local runeData = playerman.PlayerGui.GameGui.RuneFrame.Content.OpenRunes.RuneData

for _,v in next, getconnections(player.Idled) do 
	v:Disable()
end





-- < Window > --
Window = Library:CreateWindow({
	Title = 'Money Simulator Z',
	Center = true,
	AutoShow = true,
	TabPadding = 8,
	MenuFadeTime = 0.2
})



-- < Tabs > --
local Tabs = {
	Factory = Window:AddTab("Factory"),
	Mining = Window:AddTab("Mining"),
	["Auto Buy"] = Window:AddTab("Auto Buy"),
	miscellaneous = Window:AddTab("Misc"),
	['UI Settings'] = Window:AddTab('UI Settings'),
}


for _,lockedItem in next, game:GetService("ReplicatedStorage").LockedStuff:GetChildren() do
	lockedItem.Parent = workspace
end
for _,v in next, workspace:GetChildren() do
	if string.match(v.Name, "Lock") then
		v:Destroy()
	end
end

-- < Factory Tab > --
local FactoryLeftBox = Tabs.Factory:AddLeftGroupbox('Clicking')
local FactoryRightBox = Tabs.Factory:AddRightGroupbox('Factory Upgrades')
local TreeLeftBox = Tabs.Factory:AddRightGroupbox('Tree')
local RuneLeftBox = Tabs.Factory:AddLeftGroupbox('Runes')

FactoryLeftBox:AddToggle('BoostMachines', {
	Text = 'Boost Machines',
	Default = false, 
	Tooltip = 'Boost Machines',

	Callback = function(Value)
		while Toggles.BoostMachines.Value do 
			wait() 
			fireclickdetector(workspace:WaitForChild("MachineBoost")["MachineBoost1"].ClickDetector)
		end
	end
})

FactoryLeftBox:AddToggle('BoostGems', {
	Text = 'Boost Gems',
	Default = false, 
	Tooltip = 'Boost Gems',

	Callback = function(Value)
		while Toggles.BoostGems.Value do 
			wait() 
			for _,v in next, game:GetService("Workspace").Factory.Gems:GetChildren() do 
				fireclickdetector(v.ClickDetector)
			end
		end
	end
})

FactoryLeftBox:AddToggle("CollectGems", {
	Text = 'Collect Gems',
	Default = false,
	Tooltip = 'Auto Collect Gems',

	Callback = function(value)
		while Toggles.CollectGems.Value do 
			task.wait() 
			for _,v in next, game:GetService("Workspace").Factory.Gems:GetChildren() do 
				fireclickdetector(v.ClickDetector)
			end
		end 
	end
})

local function formatGrid()
	local grid = {}

	local gridValue = player.Stats.GemGrid.Value 

	for _,v in next, gridValue:split(":") do 
		table.insert(grid, v)
	end
	return grid
end

FactoryLeftBox:AddToggle('MergeGems', {
	Text = 'Merge Gems',
	Default = false, 
	Tooltip = 'Merge Grid Gems',

	Callback = function(Value)
		while Toggles.MergeGems.Value do 
			wait() 
			local grid = formatGrid()
			for i = 1, #grid do
				for j = i + 1, #grid do
					if i ~= j and grid[i] == grid[j] then
						events.GemGrid:FireServer(i, j)
						wait(.1)
						break
					end
				end
			end
		end
	end
})

TreeLeftBox:AddToggle('ClickTree', {
	Text = 'Click Tree',
	Default = false, 
	Tooltip = 'Auto Click Tree',

	Callback = function(Value)
		while Toggles.ClickTree.Value do 
			wait() 
			events.HitTree:FireServer()
		end
	end
})

TreeLeftBox:AddToggle('CollectTree', {
	Text = 'Collect Tree',
	Default = false, 
	Tooltip = 'Auto Collect Tree Money',

	Callback = function(Value)
		while Toggles.CollectTree.Value do 
			wait() 
			if player.Character and player.Character.PrimaryPart then
				for _,v in next, game:GetService("Workspace").Factory.TreeObjects:GetChildren() do 
					v.CanCollide = false
					v.CFrame = player.Character.HumanoidRootPart.CFrame
				end
			end
		end
	end
})

TreeLeftBox:AddToggle('CollectTreeOV', {
	Text = 'Collect Tree Money (Other Version)',
	Default = false, 
	Tooltip = 'Auto Collect Tree Money',

	Callback = function(Value)
		while Toggles.CollectTreeOV.Value do 
			wait() 
			local playerHead = game.Players.LocalPlayer.Character.Head
			local tree1 = game:GetService("Workspace").Factory.TreeObjects

			-- Check if Gem1 exists
			if tree1 then
				for _, v in pairs(tree1:GetDescendants()) do
					if v.Name == "TouchInterest" and v.Parent then
						firetouchinterest(game:GetService('Players').LocalPlayer.Character.HumanoidRootPart, v.Parent, 0)
					end
				end
			else
				warn("Damn Ok")
			end
		end
	end
})



local factoryUpgradeLimits = {
	[1] = 20,
	[2] = 18,
	[3] = math.huge,
	[4] = 9,
	[5] = 20,
}


FactoryRightBox:AddToggle("UpgradeFactory", {
	Text = 'Upgrade Factory',
	Default = false,
	Tooltip = 'Auto Upgrade Factory',

	Callback = function(value)
		while Toggles.UpgradeFactory.Value do 
			wait() 
			for i = 1 , 5 , 1 do 
				if player.Stats["FactoryUpgrade"..tostring(i)].Value < factoryUpgradeLimits[i] then
					events.FactoryUpgrade:FireServer(i,true)
					wait(.5)
				end
			end
		end
	end
})

FactoryRightBox:AddToggle("UpgradeMachines", {
	Text = 'Upgrade Machines',
	Default = false,
	Tooltip = 'Auto Upgrade Machines',

	Callback = function(value)
		while Toggles.UpgradeMachines.Value do 
			wait() 
			for i = 1 , 10 ,1 do 
				events.UpgradeMachine:FireServer(i,2,true)
			end 
		end
	end
})

FactoryRightBox:AddToggle("BuyMachines", {
	Text = 'Buy Machines',
	Default = false,
	Tooltip = 'Auto Buy Machines',

	Callback = function(value)
		while Toggles.BuyMachines.Value do 
			wait() 
			for i = 1 , 5 , 1 do 
				if player.Stats["FactoryUpgrade"..tostring(i)].Value < factoryUpgradeLimits[i] then
					events.BuyMachine:FireServer(i,true)
					events.BuyMoreMachines:FireServer(i,2,true)

					wait(.5)
				end
			end
		end
	end
})


-- < Mining Tab > --
local MiningLeftBox = Tabs.Mining:AddLeftGroupbox('Mining')
local QuarryLeftBox = Tabs.Mining:AddLeftGroupbox('Quarry')

local MiningRightBox = Tabs.Mining:AddRightGroupbox('Crafting')

do

	local ores = {}
	local function getOreList()
		local stringOreList = {}

		local oreList = {}
		local sortedOres = {}

		for _,ore in next, ReplicatedStorage.OresPrices:GetChildren() do
			oreList[ore.Name] = ore.Value
			table.insert(stringOreList, ore.Name)
		end

		for oreName, _ in pairs(oreList) do
			table.insert(sortedOres, oreName)
		end

		table.sort(sortedOres, function(a, b)
			return oreList[a] < oreList[b]
		end)

		local priorityOres = {}
		for i, oreName in ipairs(sortedOres) do
			priorityOres[oreName] = i
		end

		local priorityOresStrings = {}
		local amount = 0
		for _, oreName in ipairs(sortedOres) do
			table.insert(priorityOresStrings, oreName)
			amount += 1
		end

		return priorityOres, priorityOresStrings, amount
	end
	local oreList, stringOreList, totalOres = getOreList()






	local function getDepth(position)
		return math.abs(math.floor(position.Y / 6))
	end
	if not getgenv().miningDepth then
		getgenv().miningDepth = 100
	end

	for _, child in next, workspace.MineChunks:GetChildren() do
		child.ChildAdded:Connect(function(child)
			if oreList[child.Name] then
				table.insert(ores, child)
				table.sort(ores, function(a,b)
					local priorityA = oreList[a.Name] or 0
					local priorityB = oreList[b.Name] or 0
					return priorityA > priorityB
				end)
			end
		end)
	end

	workspace.MineChunks.ChildAdded:Connect(function(child)
		wait()
		child.ChildAdded:Connect(function(child)
			if oreList[child.Name] then
				table.insert(ores, child)
				table.sort(ores, function(a,b)
					local priorityA = oreList[a.Name] or 0
					local priorityB = oreList[b.Name] or 0
					return priorityA > priorityB
				end)
			end
		end)
	end)

	local function getAllAttackableOres(ignoreStone, range, enforceDepth)
		if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
			return
		end

		local attackableOres = {}
		local distance = range or (18 + player.Stats.MiningUpgrade4.Value * 6)
		local rootPartPosition = player.Character.HumanoidRootPart.Position

		for _, chunk in ipairs(workspace.MineChunks:GetChildren()) do 
			for _, ore in ipairs(chunk:GetChildren()) do
				if ore:IsA("BasePart") and ore.Name ~= "Bedrock" and ore:FindFirstChild("Health") and ore.Health.Value > 0 then
					local orePosition = ore.Position
					local distanceToOre = (orePosition - rootPartPosition).Magnitude

					if ignoreStone then
						if oreList[ore.Name] then
							table.insert(attackableOres, ore)
						end
					else
						if distanceToOre <= distance then
							if enforceDepth then
								if getDepth(orePosition) == getgenv().miningDepth then
									table.insert(attackableOres, ore)
								end
							else
								table.insert(attackableOres, ore)
							end
						end
					end
				end
			end
		end

		if not ignoreStone and #attackableOres == 0 and range == math.huge and enforceDepth then
			local lowestY = math.huge
			local lowestOre = nil
			for _, chunk in ipairs(workspace.MineChunks:GetChildren()) do 
				for _, ore in ipairs(chunk:GetChildren()) do
					local orePosition = ore.Position
					local oreY = orePosition.Y
					if oreY < lowestY and ore.Name ~= "Bedrock" then
						lowestY = oreY
						lowestOre = ore
					end
				end
			end
			return {lowestOre}

		elseif ignoreStone and #attackableOres == 0 then
			return getAllAttackableOres(false, math.huge, enforceDepth)
		end

		return attackableOres
	end

	local function getNextMiningOre(bool, distance, rec)
		local found = false
		for _,v in next, ores do
			found = true
			break
		end
		if not found and not rec then
			ores = getAllAttackableOres(bool, distance, true)
			table.sort(ores, function(a,b)
				local priorityA = oreList[a.Name] or 0
				local priorityB = oreList[b.Name] or 0
				return priorityA > priorityB
			end)
			return getNextMiningOre(bool, distance, true)
		end
		return ores[1]
	end

	local highlight = Instance.new("Highlight")
	highlight.FillColor = Color3.new(0,255,0)
	QuarryLeftBox:AddToggle('AutoMineQuarry', {
		Text = 'Auto Mine Quarry',
		Default = false,
		Tooltip = 'Automatically mines quarry for you.',

		Callback = function(Value)
			while Toggles.AutoMineQuarry.Value do
				task.wait()
				local ore = getNextMiningOre(true, math.huge)
				if ore then
					highlight.Enabled = true
					highlight.Parent = ore
					task.spawn(function()
						repeat
							getgenv().isMiningQuarry = true
							if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
								player.Character.HumanoidRootPart.CFrame = ore.CFrame
							else
								break
							end
							task.wait()
						until not ore or not ore.Parent or not Toggles.AutoMineQuarry.Value
					end)
					if ore:FindFirstChild("Health") then
						local health = ore.Health.Value
						local t = tick()
						repeat
							game:GetService("ReplicatedStorage").Events.Mine:FireServer(ore)
							if ore:FindFirstChild("Health") then
								if ore.Health.Value ~= health then
									health = ore.Health.Value
								elseif tick() - t > 1 then
									highlight.Parent = game:GetService("CoreGui")
									highlight.Enabled = false
									ore:Destroy()
									break
								end
							end
							wait()
						until not ore.Parent or not Toggles.AutoMineQuarry.Value
						table.remove(ores, table.find(ores, ore))

						getgenv().isMiningQuarry = false
						if not Toggles.AutoMineQuarry.Value then
							break
						end
					end
				else
					player.Character.HumanoidRootPart.CFrame = CFrame.new(19.9446526, 7.64234638, 2525.29077, 0.999993265, -4.27085887e-08, -0.00367515767, 4.28989821e-08, 1, 5.17268433e-08, 0.00367515767, -5.18841539e-08, 0.999993265)
				end
			end
		end
	})


	QuarryLeftBox:AddToggle("MineQuarOV", {
		Text = 'Mine Quarry (No TP)',
		Default = false,
		Tooltip = 'Auto Mines Ores Around You Within 30 Studs',

		Callback = function(value)
			while Toggles.MineQuarOV.Value do 
				wait(.5) 
				local Players = game:GetService("Players")
				local ReplicatedStorage = game:GetService("ReplicatedStorage")
				local LocalPlayer = Players.LocalPlayer
				local MineChunks = game.Workspace.MineChunks -- Change to your specific folder
				local MineRemote = ReplicatedStorage.Events.Mine

				-- Function to calculate the distance between two vectors
				local function CalculateDistance(point1, point2)
					return (point1 - point2).Magnitude
				end

				-- Function to randomly mine parts within the MineChunks folder within a specified range
				local function RandomlyMineParts(folder, maxDistance)
					local partsToMine = {}

					local localPlayerPosition = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
					if not localPlayerPosition then
						return
					end

					for _, child in ipairs(folder:GetDescendants()) do
						if child:IsA("BasePart") then
							local partPosition = child.Position
							local distance = CalculateDistance(partPosition, localPlayerPosition.Position)

							if distance <= maxDistance then
								table.insert(partsToMine, child)
							end
						end
					end

					if #partsToMine > 0 then
						local randomIndex = math.random(1, #partsToMine)
						local randomPart = partsToMine[randomIndex]

						-- Fire the remote for the randomly selected part
						local args = {
							[1] = randomPart,
						}
						MineRemote:FireServer(unpack(args))
					end
				end

				-- Set the maximum distance (e.g., 300 studs)
				local maxDistance = 7

				-- Call the function to randomly mine a part from the MineChunks folder within the specified range
				RandomlyMineParts(MineChunks, maxDistance)
			end
		end
	})


	local prioritySlider
	QuarryLeftBox:AddDropdown('MiningQuarryDropdown', {
		Values = stringOreList,
		Default = 0,
		Multi = false,

		Text = 'Ore Priority',
		Tooltip = 'Prioritize An Ore',
		Callback = function(value)
			getgenv().selectedQuarryOre = value
			local priority = oreList[value] or 0
			prioritySlider:SetValue(priority)
		end
	})

	prioritySlider = QuarryLeftBox:AddSlider('MiningPriority', {
		Text = 'Priority',
		Default = 0,
		Min = 0,
		Max = totalOres,
		Rounding = 0,
		Compact = false,
		HideMax = true, 

		Callback = function(value)
			if not getgenv().selectedQuarryOre and value > 0 then
				prioritySlider:SetValue(0)
			else
				oreList[getgenv().selectedQuarryOre] = value
			end 
		end
	})



	QuarryLeftBox:AddToggle('AutoMineQuarryLegit', {
		Text = 'Mine Aura Quarry',
		Default = false,
		Tooltip = 'Mining Aura',

		Callback = function(Value)
			while Toggles.AutoMineQuarryLegit.Value do
				repeat task.wait() until not getgenv().isMiningQuarry
				task.wait()
				local ore = getNextMiningOre(true)
				if not Toggles.AutoMineQuarry.Value then
					if ore and (ore.Position - player.Character.HumanoidRootPart.Position).Magnitude <= (18 + player.Stats.MiningUpgrade4.Value * 6) and not getgenv().isMiningQuarry then
						highlight.Parent = ore
						highlight.Enabled = true
						repeat
							game:GetService("ReplicatedStorage").Events.Mine:FireServer(ore)
							wait()
						until not ore or not ore.Parent or not Toggles.AutoMineQuarryLegit.Value or getgenv().isMiningQuarry or not ((ore.Position - player.Character.HumanoidRootPart.Position).Magnitude < 10 )
						table.remove(ores, table.find(ores, ore))
						highlight.Parent = game:GetService("CoreGui")
						highlight.Enabled = false
						if not Toggles.AutoMineQuarryLegit.Value then
							break
						end
					end
				end
			end
		end
	})

	QuarryLeftBox:AddSlider('Depth', {
		Text = 'Mining Depth',
		Default = 100,
		Min = 0,
		Max = 1000,
		Rounding = 0,
		Compact = false,
		HideMax = true, 

		Callback = function(value)
			getgenv().miningDepth = value
			ores = {}
		end
	})
end


function getNextOre()
	local ores = {}

	for _, ore in next, workspace.Ores:GetChildren() do
		if tonumber(ore.Name) ~= 0 then
			local oreName = ore:FindFirstChild("OreName")
			if oreName and not getgenv().miningBlacklist[oreName.Value] then
				local priority = getgenv().miningPriority[oreName.Value] or 0
				table.insert(ores, {ore = ore, priority = priority})
			end
		end
	end

	table.sort(ores, function(a, b)
		return a.priority > b.priority
	end)

	if ores[1] then 
		return ores[1].ore
	else
		return false
	end
end


MiningLeftBox:AddToggle('AutoMine', {
	Text = 'Auto Mine',
	Default = false,
	Tooltip = 'Auto Mines',

	Callback = function(Value)
		while Toggles.AutoMine.Value do 
			task.wait() 
			local ore = getNextOre() 
			if ore then 
				local oldParent = ore.Parent
				events.MineOre:FireServer(tonumber(ore.Name))
				local t = tick()
				repeat 
					task.wait() 
					if tick() - t > 1 then 
						t = tick() 
						events.MineOre:FireServer(tonumber(ore.Name))
					end
				until ore.Parent ~= oldParent or not Toggles.AutoMine.Value
			end
		end
	end
})

MiningLeftBox:AddToggle('AutoMineOther', {
	Text = 'Auto Mine (Other Version)',
	Default = false,
	Tooltip = 'Auto Mines',

	Callback = function(Value)
		while Toggles.AutoMineOther.Value do 
			task.wait()
			local Workspace = game:GetService("Workspace")
			local ReplicatedStorage = game:GetService("ReplicatedStorage")

			local oreParts = Workspace.Ores:GetChildren()
			local localPlayer = game:GetService("Players").LocalPlayer
			local mineTier = localPlayer.Stats.MineTier.Value

			if #oreParts == 0 then
				wait(.25) -- Wait for a brief moment before checking again
			else
				local targetBrickColor = BrickColor.new("Plum") -- Color to ignore

				local nonPlumOreFound = false
				local prioritizedOrePart = nil

				for _, orePart in pairs(oreParts) do
					if orePart.BrickColor ~= targetBrickColor then
						nonPlumOreFound = true
						prioritizedOrePart = orePart
						break
					end
				end

				if nonPlumOreFound then
					local partName = prioritizedOrePart.Name
					local oreNumber = tonumber(partName)

					if oreNumber then
						local args = {
							[1] = oreNumber
						}

						local MineOreEvent = ReplicatedStorage.Events.MineOre
						local success, result = pcall(function()
							MineOreEvent:FireServer(unpack(args))
						end)

						if success and result == true then
							prioritizedOrePart:Destroy()
						else
							-- Handle mining failure
						end
					end
				else
					-- All ores are "Plum"
					local EnterMineTierEvent = ReplicatedStorage.Events.EnterMineTier
					local initialMineTier = mineTier
					local args = {
						[1] = math.max(mineTier - 1, 1)
					}
					EnterMineTierEvent:FireServer(unpack(args))
					wait(.15) -- Wait for 1 second before firing the next remote

					args[1] = math.max(initialMineTier, 1) -- Use the initial mineTier value
					EnterMineTierEvent:FireServer(unpack(args))
					wait(.15)
				end

			end
		end
	end
})



MiningLeftBox:AddToggle('AutoMineNormalD', {
	Text = 'Auto Mine (Normal Diamonds)',
	Default = false,
	Tooltip = 'Auto Mines',

	Callback = function(Value)
		while Toggles.AutoMineNormalD.Value do
			task.wait()
			local Workspace = game:GetService("Workspace")
			local ReplicatedStorage = game:GetService("ReplicatedStorage")

			local oreParts = Workspace.Ores:GetChildren()
			local localPlayer = game:GetService("Players").LocalPlayer
			local mineTier = localPlayer.Stats.MineTier.Value

			if #oreParts == 0 then
				wait(.25) -- Wait for a brief moment before checking again
			else
				local targetBrickColor = BrickColor.new("Medium blue") -- Color to look for
				local prioritizedOrePart = nil

				for _, orePart in pairs(oreParts) do
					if orePart.BrickColor == targetBrickColor then
						prioritizedOrePart = orePart
						break
					end
				end

				if prioritizedOrePart then
					local partName = prioritizedOrePart.Name
					local oreNumber = tonumber(partName)

					if oreNumber then
						local args = {
							[1] = oreNumber
						}

						local MineOreEvent = ReplicatedStorage.Events.MineOre
						local success, result = pcall(function()
							MineOreEvent:FireServer(unpack(args))
						end)

						if success and result == true then
							prioritizedOrePart:Destroy()
						else
							-- Handle mining failure
						end
					end
				else
					-- No "Medium blue" ores found
					local EnterMineTierEvent = ReplicatedStorage.Events.EnterMineTier
					local initialMineTier = mineTier
					local args = {
						[1] = math.max(mineTier - 1, 1)
					}
					EnterMineTierEvent:FireServer(unpack(args))
					wait(.15) -- Wait for 0.15 seconds before firing the next remote

					args[1] = math.max(initialMineTier, 1) -- Use the initial mineTier value
					EnterMineTierEvent:FireServer(unpack(args))
					wait(.15) -- Wait for 0.15 seconds
				end
			end
		end
	end
})






do 
	getgenv().miningBlacklist = {}
	getgenv().miningPriority = {}
	local prioritySlider
	local blacklistedToggle
	local MiningDropdown
	MiningDropdown = MiningLeftBox:AddDropdown('MiningDropdown', {
		Values = {},
		Default = 1,
		Multi = false,

		Text = 'Ore Priority',
		Tooltip = 'Prioritize An Ore',
		Callback = function(value)
			getgenv().selectedOre = value 
			local priority = getgenv().miningPriority[value] or 0
			local blacklisted = getgenv().miningBlacklist[value] or false
			prioritySlider:SetValue(priority)
			blacklistedToggle:SetValue(blacklisted)
		end
	})

	prioritySlider = MiningLeftBox:AddSlider('MiningPriority', {
		Text = 'Priority',
		Default = 0,
		Min = 0,
		Max = 5,
		Rounding = 0,
		Compact = false,
		HideMax = true, 

		Callback = function(value)
			if not getgenv().selectedOre and value > 0 then
				prioritySlider:SetValue(0)
			else 
				getgenv().miningPriority[getgenv().selectedOre] = value 
			end 
		end
	})

	blacklistedToggle = MiningLeftBox:AddToggle('MiningBlacklist', {
		Text = 'Blacklist Ore',
		Default = false, 

		Callback = function(value)
			if not getgenv().selectedOre and value then 
				blacklistedToggle:SetValue(false)
			else 
				getgenv().miningBlacklist[getgenv().selectedOre] = value
			end
		end
	})

	local tree = {
		[0] = {

		},
		[1] = {
			"Coal",
			"RuneStone",
			"OreEssence"
		},
		[2] = {
			"Iron",
			"RuneStone",
			"OreEssence"
		},
		[3] = {
			"Copper",
			"RuneStone",
			"OreEssence"
		},
		[4] = {
			"Silver",
			"RuneStone",
			"OreEssence"
		},
		[5] = {
			"Gold",
			"RuneStone",
			"OreEssence"
		},
		[6] = {
			"Crystal",
			"Opal",
			"Lapis",
			"Jasper",
			"Jade",
			"Topaz",
			"RuneStone",
			"OreEssence"
		},
		[7] = {
			"Silicon",
			"RuneStone",
			"OreEssence"
		},
		[8] = {
			"Diamond",
			"RedDiamond",
			"GreenDiamond",
			"YellowDiamond",
			"BlackDiamond",
			"RuneStone",
			"OreEssence"
		},
		[9] = {
			"MegaStone",
			"RuneStone",
			"OreEssence"
		}
	}

	if game.Players.LocalPlayer.Stats.Mine.Value ~= 0 then
		MiningDropdown:SetValues(tree[game.Players.LocalPlayer.Stats.Mine.Value])
	end
	game.Players.LocalPlayer.Stats.Mine.Changed:Connect(function()
		MiningDropdown:SetValues(tree[game.Players.LocalPlayer.Stats.Mine.Value])
	end)

	MiningLeftBox:AddButton('Break Mining Animation', function()
		events.EnterMine:FireServer(1)
		repeat task.wait() until getNextOre()
		local ore = getNextOre()
		events.MineOre:FireServer(tonumber(ore.Name))
		wait()
		player.Character:BreakJoints()
		events.EnterMine:FireServer(0)
	end)
end



-- < Auto Buy Tab > --
do 
	local leftAutoBuyGroup = Tabs["Auto Buy"]:AddLeftGroupbox('Factory')
	local rightAutoBuyGroup = Tabs["Auto Buy"]:AddRightGroupbox('Mine')
	local rightQuarryAutoBuyGroup = Tabs["Auto Buy"]:AddRightGroupbox('Quarry')

	local leftTreeAutoBuyGroup = Tabs["Auto Buy"]:AddLeftGroupbox('Tree')

	local tmp = function(aa, name)
		local arr = {}
		for _,v in next, aa:GetChildren() do 
			if v:FindFirstChild(name) then 
				table.insert(arr, v[name].Text)
			end
		end 
		return arr
	end



	leftAutoBuyGroup:AddDropdown('Gems', {
		Values = tmp(game.Players.LocalPlayer.PlayerGui.GameGui.UpgradesFrame.Content.GemsFrame.List, "UpgradeName"),
		Default = 0,
		Multi = true,

		Text = 'Upgrade Gems',
		Tooltip = 'Auto Gem Upgrades',
		Callback = function(value)
			local ind = 0 
			for _,v in next, Options.Gems.Value do 
				ind += 1 
			end
			while Options.Gems.Value == value and ind > 0 do 
				task.wait()

				for _,v in next, Options.Gems.Value do 
					local ind 
					for _2,v2 in next, game.Players.LocalPlayer.PlayerGui.GameGui.UpgradesFrame.Content.GemsFrame.List:GetChildren() do 
						if v2:FindFirstChild("UpgradeName") and v2.UpgradeName.Text == _ then 
							ind = tonumber(string.split(v2.Name, "Upgrade")[2])
							break 
						end
					end 

					events.GemUpgrade:FireServer(ind)
					wait(.4)
				end 
			end
		end
	})

	leftAutoBuyGroup:AddDropdown('MergeGems', {
		Values = tmp(player.PlayerGui.GameGui.GridUpgrades.Content.List1, "UpgradeName"),
		Default = 0,
		Multi = true,

		Text = 'Upgrade Merge Gems',
		Tooltip = 'Auto Merge Gem Upgrades',
		Callback = function(value)
			local ind = 0 
			for _,v in next, Options.MergeGems.Value do 
				ind += 1 
			end
			while Options.MergeGems.Value == value and ind > 0 do 
				task.wait()

				for _,v in next, Options.MergeGems.Value do 
					local ind 
					for _2,v2 in next, player.PlayerGui.GameGui.GridUpgrades.Content.List1:GetChildren() do 
						if v2:FindFirstChild("UpgradeName") and v2.UpgradeName.Text == _ then 
							ind = tonumber(string.split(v2.Name, "Upgrade")[2])
							break 
						end
					end 

					events.UpgradeGemGrid:FireServer(ind)
					wait(.4)
				end 
			end
		end
	})
end

-- < End Of UI > --

Library:SetWatermarkVisibility(false)

local frameHistory = table.create(60, 0)
local index = 0

local function ComputeAverage()
	local average = 0

	for _, deltaTime in ipairs(frameHistory) do
		average += deltaTime
	end

	return average / 60
end


Library.KeybindFrame.Visible = false; 

Library:OnUnload(function()
	Library.Unloaded = true
end)

local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'Backquote', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind 

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)


SaveManager:IgnoreThemeSettings()


SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })


ThemeManager:SetFolder('Testosterone')
SaveManager:SetFolder('Testosterone/Money-Simulator-Z')

SaveManager:BuildConfigSection(Tabs['UI Settings'])

ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()
